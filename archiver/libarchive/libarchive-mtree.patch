# --- SDE-COPYRIGHT-NOTE-BEGIN ---
# This copyright note is auto-generated by ./scripts/Create-CopyPatch.
#
# Filename: package/.../libarchive/libarchive-mtree.patch
# Copyright (C) 2013 The OpenSDE Project
#
# More information can be found in the files COPYING and README.
#
# This patch file is dual-licensed. It is available under the license the
# patched project is licensed under, as long as it is an OpenSource license
# as defined at http://www.opensource.org/ (e.g. BSD, X11) or under the terms
# of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
# --- SDE-COPYRIGHT-NOTE-END ---

From e65bf287f0133426b26611fe3e80b51267987106 Mon Sep 17 00:00:00 2001
From: Dave Reisner <dreisner@archlinux.org>
Date: Thu, 21 Feb 2013 19:01:06 -0500
Subject: [PATCH] mtree: fix line filename length calculation. Fixes #301.
 Signed-off-by: Andres Mejia <amejia004@gmail.com>

---
 libarchive/archive_write_set_format_mtree.c |    4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/libarchive/archive_write_set_format_mtree.c b/libarchive/archive_write_set_format_mtree.c
index 9c0613c..f37f723 100644
--- a/libarchive/archive_write_set_format_mtree.c
+++ b/libarchive/archive_write_set_format_mtree.c
@@ -1855,9 +1855,9 @@ mtree_entry_setup_filenames(struct archive_write *a, struct mtree_entry *file,
 		return (ret);
 	}
 
-	/* Make a basename from dirname and slash */
+	/* Make a basename from file->parentdir.s and slash */
 	*slash  = '\0';
-	file->parentdir.length = slash - dirname;
+	file->parentdir.length = slash - file->parentdir.s;
 	archive_strcpy(&(file->basename),  slash + 1);
 	return (ret);
 }
-- 
1.7.10.2


From aefbb66fd6bad3d1aa62c7d372c6eae0444312f1 Mon Sep 17 00:00:00 2001
From: Andres Mejia <amejia004@gmail.com>
Date: Thu, 21 Feb 2013 19:51:22 -0500
Subject: [PATCH] Add test case for adding pathnames with no leading './' in
 mtree format. libarchive should add the leading './' for
 such pathnames.

---
 libarchive/test/test_write_format_mtree.c |  123 +++++++++++++++++++++++++++++
 1 file changed, 123 insertions(+)

diff --git a/libarchive/test/test_write_format_mtree.c b/libarchive/test/test_write_format_mtree.c
index c886709..5109e09 100644
--- a/libarchive/test/test_write_format_mtree.c
+++ b/libarchive/test/test_write_format_mtree.c
@@ -48,6 +48,26 @@ static struct {
 	{ "./subdir3/mtree",	S_IFREG | 0664, 1232266273, 1003, 1003 },
 	{ NULL, 0, 0, 0, 0 }
 };
+static struct {
+  const char  *path;
+  mode_t     mode;
+  time_t     mtime;
+  uid_t    uid;
+  gid_t    gid;
+} entries2[] = {
+  { "COPYING",    S_IFREG | 0644, 1231975636, 1001, 1001 },
+  { "Makefile",   S_IFREG | 0644, 1233041050, 1001, 1001 },
+  { "NEWS",     S_IFREG | 0644, 1231975636, 1001, 1001 },
+  { "PROJECTS",   S_IFREG | 0644, 1231975636, 1001, 1001 },
+  { "README",   S_IFREG | 0644, 1231975636, 1001, 1001 },
+  { "subdir",   S_IFDIR | 0755, 1233504586, 1001, 1001 },
+  { "subdir/README",  S_IFREG | 0664, 1231975636, 1002, 1001 },
+  { "subdir/config",  S_IFREG | 0664, 1232266273, 1003, 1003 },
+  { "subdir2",    S_IFDIR | 0755, 1233504586, 1001, 1001 },
+  { "subdir3",    S_IFDIR | 0755, 1233504586, 1001, 1001 },
+  { "subdir3/mtree",  S_IFREG | 0664, 1232266273, 1003, 1003 },
+  { NULL, 0, 0, 0, 0 }
+};
 
 static void
 test_write_format_mtree_sub(int use_set, int dironly)
@@ -136,6 +156,97 @@ test_write_format_mtree_sub(int use_set, int dironly)
 	assertEqualInt(ARCHIVE_OK, archive_read_free(a));
 }
 
+static void
+test_write_format_mtree_sub2(int use_set, int dironly)
+{
+  struct archive_entry *ae;
+  struct archive* a;
+  size_t used;
+  int i;
+  char str[32];
+
+  /* Create a mtree format archive. */
+  assert((a = archive_write_new()) != NULL);
+  assertEqualIntA(a, ARCHIVE_OK, archive_write_set_format_mtree(a));
+  if (use_set)
+    assertEqualIntA(a, ARCHIVE_OK, archive_write_set_format_option(a, NULL, "use-set", "1"));
+  if (dironly)
+    assertEqualIntA(a, ARCHIVE_OK, archive_write_set_format_option(a, NULL, "dironly", "1"));
+  assertEqualIntA(a, ARCHIVE_OK, archive_write_open_memory(a, buff, sizeof(buff)-1, &used));
+
+  /* Write entries2 */
+  for (i = 0; entries2[i].path != NULL; i++) {
+    assert((ae = archive_entry_new()) != NULL);
+    archive_entry_set_mtime(ae, entries2[i].mtime, 0);
+    assert(entries2[i].mtime == archive_entry_mtime(ae));
+    archive_entry_set_mode(ae, entries2[i].mode);
+    assert(entries2[i].mode == archive_entry_mode(ae));
+    archive_entry_set_uid(ae, entries2[i].uid);
+    assert(entries2[i].uid == archive_entry_uid(ae));
+    archive_entry_set_gid(ae, entries2[i].gid);
+    assert(entries2[i].gid == archive_entry_gid(ae));
+    archive_entry_copy_pathname(ae, entries2[i].path);
+    if ((entries2[i].mode & AE_IFMT) != S_IFDIR)
+      archive_entry_set_size(ae, 8);
+    assertEqualIntA(a, ARCHIVE_OK, archive_write_header(a, ae));
+    if ((entries2[i].mode & AE_IFMT) != S_IFDIR)
+      assertEqualIntA(a, 8,
+          archive_write_data(a, "Hello012", 15));
+    archive_entry_free(ae);
+  }
+  assertEqualIntA(a, ARCHIVE_OK, archive_write_close(a));
+        assertEqualInt(ARCHIVE_OK, archive_write_free(a));
+
+  if (use_set) {
+    const char *p;
+
+    buff[used] = '\0';
+    assert(NULL != (p = strstr(buff, "\n/set ")));
+    if (p != NULL) {
+      char *r;
+      const char *o;
+      p++;
+      r = strchr(p, '\n');
+      if (r != NULL)
+        *r = '\0';
+      if (dironly)
+        o = "/set type=dir uid=1001 gid=1001 mode=755";
+      else
+        o = "/set type=file uid=1001 gid=1001 mode=644";
+      assertEqualString(o, p);
+      if (r != NULL)
+        *r = '\n';
+    }
+  }
+
+  /*
+   * Read the data and check it.
+   */
+  assert((a = archive_read_new()) != NULL);
+  assertEqualIntA(a, ARCHIVE_OK, archive_read_support_format_all(a));
+  assertEqualIntA(a, ARCHIVE_OK, archive_read_support_filter_all(a));
+  assertEqualIntA(a, ARCHIVE_OK, archive_read_open_memory(a, buff, used));
+
+  /* Read entries2 */
+  memset(str, 0, sizeof(str));
+  strcpy(str, "./");
+  for (i = 0; entries2[i].path != NULL; i++) {
+    if (dironly && (entries2[i].mode & AE_IFMT) != S_IFDIR)
+      continue;
+    assertEqualIntA(a, ARCHIVE_OK, archive_read_next_header(a, &ae));
+    assertEqualInt(entries2[i].mtime, archive_entry_mtime(ae));
+    assertEqualInt(entries2[i].mode, archive_entry_mode(ae));
+    assertEqualInt(entries2[i].uid, archive_entry_uid(ae));
+    assertEqualInt(entries2[i].gid, archive_entry_gid(ae));
+    strcpy(str + 2, entries2[i].path);
+    assertEqualString(str, archive_entry_pathname(ae));
+    if ((entries2[i].mode & AE_IFMT) != S_IFDIR)
+      assertEqualInt(8, archive_entry_size(ae));
+  }
+  assertEqualIntA(a, ARCHIVE_OK, archive_read_close(a));
+  assertEqualInt(ARCHIVE_OK, archive_read_free(a));
+}
+
 DEFINE_TEST(test_write_format_mtree)
 {
 	/* Default setting */
@@ -147,3 +258,15 @@ DEFINE_TEST(test_write_format_mtree)
 	/* Use /set keyword with directory only */
 	test_write_format_mtree_sub(1, 1);
 }
+
+DEFINE_TEST(test_write_format_mtree_no_leading_dotslash)
+{
+  /* Default setting */
+  test_write_format_mtree_sub2(0, 0);
+  /* Directory only */
+  test_write_format_mtree_sub2(0, 1);
+  /* Use /set keyword */
+  test_write_format_mtree_sub2(1, 0);
+  /* Use /set keyword with directory only */
+  test_write_format_mtree_sub2(1, 1);
+}
-- 
1.7.10.2

