# --- SDE-COPYRIGHT-NOTE-BEGIN ---
# This copyright note is auto-generated by ./scripts/Create-CopyPatch.
# 
# Filename: package/.../qemu/qemu-0.9.0-x86_64-opts.patch
# Copyright (C) 2007 The OpenSDE Project
# 
# More information can be found in the files COPYING and README.
# 
# This patch file is dual-licensed. It is available under the license the
# patched project is licensed under, as long as it is an OpenSource license
# as defined at http://www.opensource.org/ (e.g. BSD, X11) or under the terms
# of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
# --- SDE-COPYRIGHT-NOTE-END ---

2007-04-12  rediffed for qemu 0.9.0

2007-02-03  Gwenole Beauchesne  <gbeauchesne@mandriva.com>

        * dyngen-exec.h (AREG4, AREG5): Enable when building with GCC4.

2005-06-04  Gwenole Beauchesne  <gbeauchesne@mandriva.com>

        * Add direct jump support to x86-64.

diff -ruN qemu-0.9.0/dyngen-exec.h qemu-0.9.0-x86_64-opts/dyngen-exec.h
--- qemu-0.9.0/dyngen-exec.h	2007-02-06 00:01:54.000000000 +0100
+++ qemu-0.9.0-x86_64-opts/dyngen-exec.h	2007-04-12 17:32:09.000000000 +0200
@@ -95,8 +95,11 @@
 #define AREG1 "rbx"
 #define AREG2 "r12"
 #define AREG3 "r13"
-//#define AREG4 "r14"
-//#define AREG5 "r15"
+#if __GNUC__ >= 4
+/* XXX: earlier GCC crashes */
+#define AREG4 "r14"
+#define AREG5 "r15"
+#endif
 #endif
 #ifdef __powerpc__
 #define AREG0 "r27"
diff -ruN qemu-0.9.0/dyngen.c qemu-0.9.0-x86_64-opts/dyngen.c
--- qemu-0.9.0/dyngen.c	2007-02-06 00:01:54.000000000 +0100
+++ qemu-0.9.0-x86_64-opts/dyngen.c	2007-04-12 17:32:09.000000000 +0200
@@ -1891,6 +1891,17 @@
                 if (rel->r_offset >= start_offset &&
 		    rel->r_offset < start_offset + copy_size) {
                     sym_name = strtab + symtab[ELFW(R_SYM)(rel->r_info)].st_name;
+                    if (strstart(sym_name, "__op_jmp", &p)) {
+                        int n;
+                        n = strtol(p, NULL, 10);
+                        /* __op_jmp relocations are done at
+                           runtime to do translated block
+                           chaining: the offset of the instruction
+                           needs to be stored */
+                        fprintf(outfile, "    jmp_offsets[%d] = %d + (gen_code_ptr - gen_code_buf);\n",
+                                n, rel->r_offset - start_offset);
+                        continue;
+                    }
                     get_reloc_expr(name, sizeof(name), sym_name);
                     type = ELF32_R_TYPE(rel->r_info);
                     addend = rel->r_addend;
diff -ruN qemu-0.9.0/exec-all.h qemu-0.9.0-x86_64-opts/exec-all.h
--- qemu-0.9.0/exec-all.h	2007-02-06 00:01:54.000000000 +0100
+++ qemu-0.9.0-x86_64-opts/exec-all.h	2007-04-12 17:32:09.000000000 +0200
@@ -159,6 +159,9 @@
 #if defined(__i386__) && !defined(_WIN32)
 #define USE_DIRECT_JUMP
 #endif
+#if defined(__x86_64__)
+#define USE_DIRECT_JUMP
+#endif
 
 typedef struct TranslationBlock {
     target_ulong pc;   /* simulated PC corresponding to this block (EIP + CS base) */
@@ -245,7 +248,7 @@
     asm volatile ("sync" : : : "memory");
     asm volatile ("isync" : : : "memory");
 }
-#elif defined(__i386__)
+#elif defined(__i386__) || defined(__x86_64__)
 static inline void tb_set_jmp_target1(unsigned long jmp_addr, unsigned long addr)
 {
     /* patch the branch destination */
@@ -324,7 +327,7 @@
 		  "1:\n");\
 } while (0)
 
-#elif defined(__i386__) && defined(USE_DIRECT_JUMP)
+#elif (defined(__i386__) || defined(__x86_64__)) && defined(USE_DIRECT_JUMP)
 
 /* we patch the jump instruction directly */
 #define GOTO_TB(opname, tbparam, n)\
