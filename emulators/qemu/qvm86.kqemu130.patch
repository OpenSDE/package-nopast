# --- SDE-COPYRIGHT-NOTE-BEGIN ---
# This copyright note is auto-generated by ./scripts/Create-CopyPatch.
# 
# Filename: package/.../qemu/qvm86.kqemu130.patch
# Copyright (C) 2006 The OpenSDE Project
# 
# More information can be found in the files COPYING and README.
# 
# This patch file is dual-licensed. It is available under the license the
# patched project is licensed under, as long as it is an OpenSource license
# as defined at http://www.opensource.org/ (e.g. BSD, X11) or under the terms
# of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
# --- SDE-COPYRIGHT-NOTE-END ---

by Jim C. Brown <jma5@umd.edu>
http://lists.gnu.org/archive/html/qvm86-devel/2006-02/msg00000.html

diff -ur qvm86.orig/kqemu.h qvm86/kqemu.h
--- ./qvm86.orig/kqemu.h	Thu Jul 28 12:22:55 2005
+++ ./qvm86/kqemu.h	Tue Feb 14 20:45:43 2006
@@ -1,11 +1,7 @@
 #ifndef KQEMU_H
 #define KQEMU_H
 
-#ifdef _WIN32
-#define KQEMU_VERSION 0x010101
-#else
-#define KQEMU_VERSION 0x010000
-#endif
+#define KQEMU_VERSION 0x010300
 
 struct kqemu_segment_cache {
     uint32_t selector;
@@ -15,9 +11,13 @@
 };
 
 struct kqemu_cpu_state {
-    uint32_t regs[8];
-    uint32_t eip;
-    uint32_t eflags;
+#ifdef __x86_64__
+    unsigned long regs[16];
+#else
+    unsigned long regs[8];
+#endif
+    unsigned long eip;
+    unsigned long eflags;
 
     uint32_t dummy0, dummy1, dumm2, dummy3, dummy4;
 
@@ -27,31 +27,48 @@
     struct kqemu_segment_cache gdt; /* only base and limit are used */
     struct kqemu_segment_cache idt; /* only base and limit are used */
 
-    uint32_t cr0;
-    uint32_t dumm5;
-    uint32_t cr2;
-    uint32_t cr3;
-    uint32_t cr4;
+    unsigned long cr0;
+    unsigned long dumm5;
+    unsigned long cr2;
+    unsigned long cr3;
+    unsigned long cr4;
     uint32_t a20_mask;
 
-    uint32_t dr0;
-    uint32_t dr1;
-    uint32_t dr2;
-    uint32_t dr3;
-    uint32_t dr6;
-    uint32_t dr7;
+    uint32_t sysenter_cs;
+    uint32_t sysenter_esp;
+    uint32_t sysenter_eip;
+    uint64_t efer __attribute__((aligned(8)));
+    uint64_t star;
+#ifdef __x86_64__
+    unsigned long lstar;
+    unsigned long cstar;
+    unsigned long fmask;
+    unsigned long kernelgsbase;
+#endif
+    uint64_t tsc_offset;
+
+    unsigned long dr0;
+    unsigned long dr1;
+    unsigned long dr2;
+    unsigned long dr3;
+    unsigned long dr6;
+    unsigned long dr7;
 
-    int cpl; /* currently only 3 */
+    uint8_t cpl; /* currently only 3 */
+    uint8_t user_only;
 
     uint32_t error_code; /* error_code when exiting with an exception */
-    uint32_t next_eip; /* next eip value when exiting with an interrupt */
+    unsigned long next_eip; /* next eip value when exiting with an interrupt */
     unsigned int nb_pages_to_flush; /* number of pages to flush,
-                                       KQEMU_FLUSH_ALL means full flush */
+				       KQEMU_FLUSH_ALL means full flush */
 #define KQEMU_MAX_PAGES_TO_FLUSH 512
 #define KQEMU_FLUSH_ALL (KQEMU_MAX_PAGES_TO_FLUSH + 1)
-#ifdef _WIN32
-    uint32_t retval;
-#endif
+    long retval;
+    unsigned int nb_ram_pages_to_update;
+    unsigned int nb_modified_ram_pages;
+#define KQEMU_MAX_RAM_PAGES_TO_UPDATE 512
+#define KQEMU_RAM_PAGES_UPDATE_ALL (KQEMU_MAX_RAM_PAGES_TO_UPDATE + 1)
+#define KQEMU_MAX_MODIFIED_RAM_PAGES 512
 };
 
 struct kqemu_init {
@@ -60,23 +77,28 @@
     uint8_t *ram_dirty; /* must be page aligned */
     uint32_t **phys_to_ram_map; /* must be page aligned */
     unsigned long *pages_to_flush; /* must be page aligned */
+    unsigned long *ram_pages_to_update; /* must be page aligned */
+    unsigned long *modified_ram_pages; /* must be page aligned */
 };
 
 #define KQEMU_RET_ABORT    (-1)
 #define KQEMU_RET_EXCEPTION 0x0000 /* 8 low order bit are the exception */
 #define KQEMU_RET_INT       0x0100 /* 8 low order bit are the interrupt */
 #define KQEMU_RET_SOFTMMU   0x0200 /* emulation needed (I/O or
-                                      unsupported INSN) */
+				      unsupported INSN) */
 #define KQEMU_RET_INTR      0x0201 /* interrupted by a signal */
+#define KQEMU_RET_SYSCALL   0x0300 /* syscall insn */
 
 #ifdef _WIN32
 #define KQEMU_EXEC           CTL_CODE(FILE_DEVICE_UNKNOWN, 1, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
 #define KQEMU_INIT           CTL_CODE(FILE_DEVICE_UNKNOWN, 2, METHOD_BUFFERED, FILE_WRITE_ACCESS)
 #define KQEMU_GET_VERSION    CTL_CODE(FILE_DEVICE_UNKNOWN, 3, METHOD_BUFFERED, FILE_READ_ACCESS)
+#define KQEMU_MODIFY_RAM_PAGES CTL_CODE(FILE_DEVICE_UNKNOWN, 4, METHOD_BUFFERED, FILE_WRITE_ACCESS)
 #else
 #define KQEMU_EXEC           _IOWR('q', 1, struct kqemu_cpu_state)
 #define KQEMU_INIT           _IOW('q', 2, struct kqemu_init)
 #define KQEMU_GET_VERSION    _IOR('q', 3, int)
+#define KQEMU_MODIFY_RAM_PAGES _IOW('q', 4, int)
 #endif
 
 #endif /* KQEMU_H */
diff -ur qvm86.orig/qvm86-host.c qvm86/qvm86-host.c
--- ./qvm86.orig/qvm86-host.c	Tue Aug 23 20:14:20 2005
+++ ./qvm86/qvm86-host.c	Tue Feb 14 20:57:01 2006
@@ -1209,9 +1209,19 @@
 printk ("eax:%08x, ebx:%08x, ecx:%08x, edx:%08x\n", hostenv->regs[0], hostenv->regs[3], hostenv->regs[1], hostenv->regs[2]);
 printk ("esi:%08x, edi:%08x, ebp:%08x, esp:%08x\n", hostenv->regs[6], hostenv->regs[7], hostenv->regs[5], hostenv->regs[4]);
 }
+  /* Awwwww......................... bullshit */
+  if (hostenv->cpl == 0)
+  {
+    hostenv->retval = KQEMU_RET_SOFTMMU;
+    return KQEMU_RET_SOFTMMU;
+  }
+
   /* We currently assume paging is enabled.  */
   if ((hostenv->cr0 & 0x80000000) == 0)
+  {
+    hostenv->retval = KQEMU_RET_SOFTMMU;
     return KQEMU_RET_SOFTMMU;
+  }
 
   if (qs->guest_cr3 != hostenv->cr3)
     {
@@ -1252,11 +1262,15 @@
       qvm86_clear_gdt_entries (qs, hostenv);
 
       if (i == 0x20)
+      {
+        hostenv->retval = KQEMU_RET_SOFTMMU;
 	return KQEMU_RET_SOFTMMU;
+      }
       else
 	{
 	  hostenv->error_code = i & 0xf;
 	  hostenv->cr2 = hostenv->segs[1].base + hostenv->eip;
+	  hostenv->retval = KQEMU_RET_EXCEPTION + 14;
 	  return KQEMU_RET_EXCEPTION + 14;
 	}
     }
@@ -1308,7 +1322,10 @@
 
       /* Bail out if something went wrong.  */
       if (qs->die)
+      {
+	hostenv->retval = KQEMU_RET_ABORT;
 	return KQEMU_RET_ABORT;
+      }
 
 profile_timer(0);
       /* Setup monitor state.  */
@@ -1365,6 +1382,7 @@
   if (next_offset)
     hostenv->next_eip = hostenv->eip + next_offset;
 
+  hostenv->retval = retval; /* for some reason kqemu.c requires this */
   return retval;
 }
 
@@ -1580,6 +1598,8 @@
   qs->l1_phys_map = (uint32_t *) init->phys_to_ram_map;
   qs->phys_ram_dirty = init->ram_dirty;
   qs->pages_to_flush = init->pages_to_flush;
+  qs->ram_pages_to_update = init->ram_pages_to_update;
+  qs->modified_ram_pages = init->modified_ram_pages;
   qvm86_init_shadow (qs);
   qvm86_init_monitor_stack (qs);
   qvm86_create_monitor_gdt (qs);
Only in qvm86: qvm86-host.o
diff -ur qvm86.orig/qvm86-linux.c qvm86/qvm86-linux.c
--- ./qvm86.orig/qvm86-linux.c	Thu Jul 28 12:22:55 2005
+++ ./qvm86/qvm86-linux.c	Tue Feb 14 20:14:15 2006
@@ -129,6 +129,7 @@
   int ret;
   struct page *page;
 
+  down_read(&current->mm->mmap_sem);
   ret = get_user_pages(current,
                        current->mm,
                        (unsigned long) useraddr,
@@ -138,6 +139,7 @@
                        &page,
                        NULL /* struct vm_area_struct *[] */
                        );
+  up_read(&current->mm->mmap_sem);
   /* TODO: error handling.  */
   if (ret != 1)
     printk (KERN_ERR "qvm86: host_map_user failed\n");
@@ -231,6 +233,17 @@
     case KQEMU_GET_VERSION:
       if (put_user(KQEMU_VERSION, (int *)arg) < 0)
 	ret = -EFAULT;
+      break;
+
+// called by kqemu_modify_pages()
+// modified_ram_pages are the pages that qemu had changed (by writing to) and hence are dirty
+// for userspace (which we run directly) we could care less.
+// kqemu probabaly only needs this for -kernel-kqemu - pages in ring 0 which
+// contain code and are written to will need to be updated with the binary
+// translator. Since we don't do kernel mode (yet) we can safely ignore this.
+// Paul Brook: any ETA on real -kernel-kqemu support?
+
+    case KQEMU_MODIFY_RAM_PAGES:
       break;
 
     default:
Only in qvm86: qvm86-linux.o
diff -ur qvm86.orig/qvm86.h qvm86/qvm86.h
--- ./qvm86.orig/qvm86.h	Thu Jul 28 12:22:55 2005
+++ ./qvm86/qvm86.h	Tue Feb 14 20:47:32 2006
@@ -217,6 +217,10 @@
   /* Emulator dirty memory flags.  */
   uint8_t *phys_ram_dirty;
   unsigned long *pages_to_flush;
+  /* What does this do??? */
+  unsigned long *ram_pages_to_update;
+  /* This isn't used, its needed for -kernel-kqemu only (not implemented yet) */
+  unsigned long *modified_ram_pages;
   /* Satus of mapped-in host pages.  */
   qvm86_mapped_page *host_physmem_map;
 
