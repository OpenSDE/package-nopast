# --- SDE-COPYRIGHT-NOTE-BEGIN ---
# This copyright note is auto-generated by ./scripts/Create-CopyPatch.
#
# Filename: package/.../libtiff/thumbnail-fixup.patch
# Copyright (C) 2010 The OpenSDE Project
# Copyright (C) 2004 - 2006 The T2 SDE Project
#
# More information can be found in the files COPYING and README.
#
# This patch file is dual-licensed. It is available under the license the
# patched project is licensed under, as long as it is an OpenSource license
# as defined at http://www.opensource.org/ (e.g. BSD, X11) or under the terms
# of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
# --- SDE-COPYRIGHT-NOTE-END ---

The box filter bit masking is broken in several ways - I wonder it ever worked
for anyone ...

Marked clamp inline, just in case.

  - Rene Rebe <rene@exactcode.de> for Archivista GmbH Zürich

diff -ruN tiff-3.9.4-orig/tools/thumbnail.c tiff-3.9.4/tools/thumbnail.c
--- tiff-3.9.4-orig/tools/thumbnail.c	2010-06-08 20:50:44.000000000 +0200
+++ tiff-3.9.4/tools/thumbnail.c	2010-08-13 12:08:46.272260086 +0200
@@ -369,7 +369,7 @@
     }
 }
 
-static int clamp(float v, int low, int high)
+static int inline clamp(float v, int low, int high)
     { return (v < low ? low : v > high ? high : (int)v); }
 
 #ifndef M_E
@@ -453,13 +453,15 @@
 	    }
 	    rowoff[x] = sx0 >> 3;
 	    fw = sx - sx0;		/* width */
+	    if (fw == 0) fw = 1;
+
+	    src1[x] = fw;
 	    b = (fw < 8) ? 0xff<<(8-fw) : 0xff;
 	    src0[x] = b >> (sx0&7);
 	    fw -= 8 - (sx0&7);
 	    if (fw < 0)
 		fw = 0;
-	    src1[x] = fw >> 3;
-	    fw -= (fw>>3)<<3;
+	    fw %= 8;
 	    src2[x] = 0xff << (8-fw);
 	}
 	stepSrcWidth = sw;
@@ -471,20 +473,20 @@
 setrow(uint8* row, uint32 nrows, const uint8* rows[])
 {
     uint32 x;
-    uint32 area = nrows * filterWidth;
     for (x = 0; x < tnw; x++) {
 	uint32 mask0 = src0[x];
 	uint32 fw = src1[x];
-	uint32 mask1 = src1[x];
+	uint32 mask1 = src2[x];
 	uint32 off = rowoff[x];
 	uint32 acc = 0;
 	uint32 y, i;
 	for (y = 0; y < nrows; y++) {
 	    const uint8* src = rows[y] + off;
+	    uint32 _fw = fw - bits[mask0] - bits[mask1];
 	    acc += bits[*src++ & mask0];
-	    switch (fw) {
+	    switch (_fw) {
 	    default:
-		for (i = fw; i > 8; i--)
+		for (i = _fw; i > 8; i--)
 		    acc += bits[*src++];
 		/* fall thru... */
 	    case 8: acc += bits[*src++];
@@ -499,6 +501,7 @@
 	    }
 	    acc += bits[*src & mask1];
 	}
+        uint32 area = nrows * fw;
 	*row++ = cmap[(255*acc)/area];
     }
 }
