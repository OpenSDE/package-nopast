# --- SDE-COPYRIGHT-NOTE-BEGIN ---
# This copyright note is auto-generated by ./scripts/Create-CopyPatch.
#
# Filename: package/.../open-iscsi/open-iscsi-2.0.873-upstream-fixes.patch
# Copyright (C) 2013 The OpenSDE Project
#
# More information can be found in the files COPYING and README.
#
# This patch file is dual-licensed. It is available under the license the
# patched project is licensed under, as long as it is an OpenSource license
# as defined at http://www.opensource.org/ (e.g. BSD, X11) or under the terms
# of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
# --- SDE-COPYRIGHT-NOTE-END ---

From 71cd021b74a7094b5186a42bfe59a35e2fa66018 Mon Sep 17 00:00:00 2001
From: Mike Christie <michaelc@cs.wisc.edu>
Date: Wed, 5 Sep 2012 16:18:16 -0500
Subject: [PATCH] iscsid: fix iscsid segfault during qla4xxx login

If the kernel sends multiple ISCSI_KEVENT_CONN_LOGIN_STATE
events for the same login event iscsid will segault.

When we get a conn error we will set the r_stage to reopen, then when
session_conn_process_login handles the first login event we set the r_stage
to R_STAGE_NO_CHANGE. But then it looks like if we get a second login event
r_stage is no_change and session_conn_process_login will run again and
call mgmt_ipc_write_rsp on a bad qtask.
---
 usr/initiator.c |    5 ++++-
 1 files changed, 4 insertions(+), 1 deletions(-)

diff --git a/usr/initiator.c b/usr/initiator.c
index 79ca32c..d475358 100644
--- a/usr/initiator.c
+++ b/usr/initiator.c
@@ -993,7 +993,7 @@ static void session_scan_host(struct iscsi_session *session, int hostno,
 		exit(0);
 	} else if (pid > 0) {
 		reap_inc();
-		if (qtask) {
+		if (qtask && qtask->mgmt_ipc_fd >= 0) {
 			close(qtask->mgmt_ipc_fd);
 			free(qtask);
 		}
@@ -1618,6 +1618,9 @@ static void session_conn_process_login(void *data)
 	if (state == ISCSI_CONN_STATE_FREE)
 		goto failed_login;
 
+	if (conn->state == ISCSI_CONN_STATE_LOGGED_IN)
+		return;
+
 	conn->state = ISCSI_CONN_STATE_LOGGED_IN;
 	/*
 	 * ok we were in_login and now we got the notification that we are
-- 
1.7.2.3


From f0a8c95426d21413d9980d31740e193208e3280e Mon Sep 17 00:00:00 2001
From: Eddie Wai <eddie.wai@broadcom.com>
Date: Wed, 5 Sep 2012 14:14:20 -0700
Subject: [PATCH] ISCSISTART: Bring up the corresponding network interface for iboot

This is needed for the iSCSI offload boot.

Snip from M. Christie:
Note that we must bring up the interface before iface_setup_from_boot_context,
because we will want iscsi_sysfs_get_host_no_from_hwaddress to be able to match
a MAC to a iscsi host.  For some bnx2i cards, the card has to be ifupd for the
iscsi interface to have a MAC. If it is not ifupd we have seen MACs with all
zeros or no iscsi_hosts on different cards.

Signed-off-by: Eddie Wai <eddie.wai@broadcom.com>
---
 usr/iface.c |    4 ++++
 1 files changed, 4 insertions(+), 0 deletions(-)

diff --git a/usr/iface.c b/usr/iface.c
index 3a9582e..4028e34 100644
--- a/usr/iface.c
+++ b/usr/iface.c
@@ -917,6 +917,10 @@ int iface_setup_from_boot_context(struct iface_rec *iface,
 							transport_name))
 			t = iscsi_sysfs_get_transport_by_name(transport_name);
 
+		if (net_ifup_netdev(context->iface))
+			log_warning("Could not bring up netdev %s for boot",
+				    context->iface);
+
 		hostno = iscsi_sysfs_get_host_no_from_hwaddress(context->mac,
 								&rc);
 		if (rc) {
-- 
1.7.2.3


From d81fd4903cebb1d00aa48b0718d20e34b00dfde1 Mon Sep 17 00:00:00 2001
From: Mike Christie <michaelc@cs.wisc.edu>
Date: Wed, 26 Sep 2012 21:19:39 -0500
Subject: [PATCH] iscsi tools: fix compile error when OFFLOAD_BOOT_SUPPORT defined

Fix compile error when OFFLOAD_BOOT_SUPPORT is defined and fix
warning when it is defined.
---
 usr/iface.c |    3 ++-
 1 files changed, 2 insertions(+), 1 deletions(-)

diff --git a/usr/iface.c b/usr/iface.c
index 4028e34..4f81a76 100644
--- a/usr/iface.c
+++ b/usr/iface.c
@@ -894,7 +894,6 @@ int iface_setup_from_boot_context(struct iface_rec *iface,
 				   struct boot_context *context)
 {
 	struct iscsi_transport *t = NULL;
-	char transport_name[ISCSI_TRANSPORT_NAME_MAXLEN];
 	uint32_t hostno;
 
 	if (strlen(context->initiatorname))
@@ -910,6 +909,8 @@ int iface_setup_from_boot_context(struct iface_rec *iface,
 	} else if (strlen(context->iface)) {
 /* this ifdef is only temp until distros and firmwares are updated */
 #ifdef OFFLOAD_BOOT_SUPPORTED
+		char transport_name[ISCSI_TRANSPORT_NAME_MAXLEN];
+		int rc;
 
 		memset(transport_name, 0, ISCSI_TRANSPORT_NAME_MAXLEN);
 		/* make sure offload driver is loaded */
-- 
1.7.2.3


From 13d08e79090421fbf67fd727aada487ea23ecc2d Mon Sep 17 00:00:00 2001
From: Eddie Wai <eddie.wai@broadcom.com>
Date: Thu, 27 Sep 2012 13:57:12 -0700
Subject: [PATCH] ISCSID: Passing more net params from ibft to iface

Added the passing of the vlan_id, subnet_mask, and gateway attributes
from the ibft context to the iface struct for the connection request.

Signed-off-by: Eddie Wai <eddie.wai@broadcom.com>
---
 usr/iface.c |    5 +++++
 1 files changed, 5 insertions(+), 0 deletions(-)

diff --git a/usr/iface.c b/usr/iface.c
index 4f81a76..c86892e 100644
--- a/usr/iface.c
+++ b/usr/iface.c
@@ -962,6 +962,11 @@ int iface_setup_from_boot_context(struct iface_rec *iface,
 		sizeof(iface->hwaddress));
 	strlcpy(iface->ipaddress, context->ipaddr,
 		sizeof(iface->ipaddress));
+	iface->vlan_id = atoi(context->vlan);
+	strlcpy(iface->subnet_mask, context->mask,
+		sizeof(iface->subnet_mask));
+	strlcpy(iface->gateway, context->gateway,
+		sizeof(iface->gateway));
 	log_debug(1, "iface " iface_fmt "\n", iface_str(iface));
 	return 1;
 }
-- 
1.7.2.3


From 9dd181dcb1ca299cd82075b8e598fc57d87ee1c0 Mon Sep 17 00:00:00 2001
From: Jim Ramsay <jim_ramsay@dell.com>
Date: Wed, 3 Oct 2012 09:57:43 -0400
Subject: [PATCH] iscsi tools: Convert '-r' argument to an integer before checking if it is a path

If there is a file in the CWD named '1' and you were trying to run
'iscsiadm -m session -r 1 ...', the command would fail with "1 is not a
directory".

Root cause: The code that parses the -r option's argument tries lstat(2)
first, falling back to atoi(3) only if lstat fails.

This change inverts the order of checks, first with strtol(3) to see if
the argument given is a positive integer, then falling back to lstat(2)
only if it is not.

Signed-off-by: Jim Ramsay <jim_ramsay@dell.com>
---
 usr/iscsi_sysfs.c |   17 +++++++++--------
 1 files changed, 9 insertions(+), 8 deletions(-)

diff --git a/usr/iscsi_sysfs.c b/usr/iscsi_sysfs.c
index 123dde3..4015b35 100644
--- a/usr/iscsi_sysfs.c
+++ b/usr/iscsi_sysfs.c
@@ -740,7 +740,7 @@ int iscsi_sysfs_session_has_leadconn(uint32_t sid)
  * /sys/devices/platform/hostH/sessionS/targetH:B:I
  * /sys/devices/platform/hostH/sessionS
  *
- * return the sid S. If just the sid is passed in it will be covnerted
+ * return the sid S. If just the sid is passed in it will be converted
  * to a int.
  */
 int iscsi_sysfs_get_sid_from_path(char *session)
@@ -748,15 +748,16 @@ int iscsi_sysfs_get_sid_from_path(char *session)
 	struct sysfs_device *dev_parent, *dev;
 	struct stat statb;
 	char devpath[PATH_SIZE];
+	char *end;
+	int sid;
+
+	sid = strtol(session, &end, 10);
+	if (sid > 0 && *session != '\0' && *end == '\0')
+		return sid;
 
 	if (lstat(session, &statb)) {
-		log_debug(1, "Could not stat %s failed with %d",
-			  session, errno);
-		if (index(session, '/')) {
-			log_error("%s is an invalid session path\n", session);
-			exit(1);
-		}
-		return atoi(session);
+		log_error("%s is an invalid session ID or path\n", session);
+		exit(1);
 	}
 
 	if (!S_ISDIR(statb.st_mode) && !S_ISLNK(statb.st_mode)) {
-- 
1.7.2.3


From 97db3db45c7e96888ea48a54ff19b7ff5d08cca6 Mon Sep 17 00:00:00 2001
From: Andy Grover <agrover@redhat.com>
Date: Wed, 24 Oct 2012 15:37:28 -0700
Subject: [PATCH] Update README for removal of DBM requirement

Removed in 093b1f4 (2006)

Signed-off-by: Andy Grover <agrover@redhat.com>
---
 README |   23 ++++++++++++++---------
 1 files changed, 14 insertions(+), 9 deletions(-)

diff --git a/README b/README
index 7364b2d..ec22098 100644
--- a/README
+++ b/README
@@ -159,15 +159,20 @@ Usage: iscsid [OPTION]
 5. Open-iSCSI Configuration Utility
 ===================================
 
-Open-iSCSI persistent configuration is implemented as a DBM database
-available on all Linux installations.
-
-The database contains two tables:
-
-- Discovery table (/etc/iscsi/send_targets);
-- Node table (/etc/iscsi/nodes).
-
-The regular place for iSCSI database files: /etc/iscsi/nodes
+Open-iSCSI persistent configuration is stored in a number of
+directories under a configuration root directory, using a flat-file
+format. This configuration root directory is /etc/iscsi by default,
+but may also commonly be in /var/lib/iscsi.
+
+Configuration is contained in directories for:
+
+- nodes
+- slp
+- isns
+- static
+- fw
+- send_targets
+- ifaces
 
 The iscsiadm utility is a command-line tool to manage (update, delete,
 insert, query) the persistent database.
-- 
1.7.2.3


From 2d086a831dc16d10729d6fce17bed3ade3efd16c Mon Sep 17 00:00:00 2001
From: Tomasz Torcz <tomek@pipebreaker.pl>
Date: Wed, 28 Nov 2012 13:37:06 +0100
Subject: [PATCH] iscsid,iscsiadm: fix abstract socket length in bind() call

For abstract sockets, the addrlen parameter should be the actual
length of socket's name.  Otherwise socket gets padded with some
number of NULs.
---
 usr/iscsid_req.c |   10 ++++++----
 usr/mgmt_ipc.c   |    9 +++++----
 2 files changed, 11 insertions(+), 8 deletions(-)

diff --git a/usr/iscsid_req.c b/usr/iscsid_req.c
index 0902011..1c4678d 100644
--- a/usr/iscsid_req.c
+++ b/usr/iscsid_req.c
@@ -56,7 +56,7 @@ static void iscsid_startup(void)
 
 static int iscsid_connect(int *fd, int start_iscsid)
 {
-	int nsec;
+	int nsec, addr_len;
 	struct sockaddr_un addr;
 
 	*fd = socket(AF_LOCAL, SOCK_STREAM, 0);
@@ -65,15 +65,17 @@ static int iscsid_connect(int *fd, int start_iscsid)
 		return ISCSI_ERR_ISCSID_NOTCONN;
 	}
 
+	addr_len = offsetof(struct sockaddr_un, sun_path) + strlen(ISCSIADM_NAMESPACE) + 1;
+
 	memset(&addr, 0, sizeof(addr));
 	addr.sun_family = AF_LOCAL;
-	memcpy((char *) &addr.sun_path + 1, ISCSIADM_NAMESPACE,
-		strlen(ISCSIADM_NAMESPACE));
+	memcpy((char *) &addr.sun_path + 1, ISCSIADM_NAMESPACE, addr_len);
+
 	/*
 	 * Trying to connect with exponential backoff
 	 */
 	for (nsec = 1; nsec <= MAXSLEEP; nsec <<= 1) {
-		if (connect(*fd, (struct sockaddr *) &addr, sizeof(addr)) == 0)
+		if (connect(*fd, (struct sockaddr *) &addr, addr_len) == 0)
 			/* Connection established */
 			return ISCSI_SUCCESS;
 
diff --git a/usr/mgmt_ipc.c b/usr/mgmt_ipc.c
index 5c39c2e..a1dafc9 100644
--- a/usr/mgmt_ipc.c
+++ b/usr/mgmt_ipc.c
@@ -43,7 +43,7 @@
 int
 mgmt_ipc_listen(void)
 {
-	int fd, err;
+	int fd, err, addr_len;
 	struct sockaddr_un addr;
 
 	fd = socket(AF_LOCAL, SOCK_STREAM, 0);
@@ -52,12 +52,13 @@ mgmt_ipc_listen(void)
 		return fd;
 	}
 
+	addr_len = offsetof(struct sockaddr_un, sun_path) + strlen(ISCSIADM_NAMESPACE) + 1;
+
 	memset(&addr, 0, sizeof(addr));
 	addr.sun_family = AF_LOCAL;
-	memcpy((char *) &addr.sun_path + 1, ISCSIADM_NAMESPACE,
-		strlen(ISCSIADM_NAMESPACE));
+	memcpy((char *) &addr.sun_path + 1, ISCSIADM_NAMESPACE, addr_len);
 
-	if ((err = bind(fd, (struct sockaddr *) &addr, sizeof(addr))) < 0) {
+	if ((err = bind(fd, (struct sockaddr *) &addr, addr_len)) < 0 ) {
 		log_error("Can not bind IPC socket");
 		close(fd);
 		return err;
-- 
1.7.2.3


From 5d0e19fcc1cea77a72647cf96c5d3d773e8ee277 Mon Sep 17 00:00:00 2001
From: Tomasz Torcz <tomek@pipebreaker.pl>
Date: Wed, 28 Nov 2012 13:37:07 +0100
Subject: [PATCH] iscsid: implement systemd-compatible socket activation

---
 usr/mgmt_ipc.c |   29 +++++++++++++++++++++++++++++
 usr/mgmt_ipc.h |    1 +
 2 files changed, 30 insertions(+), 0 deletions(-)

diff --git a/usr/mgmt_ipc.c b/usr/mgmt_ipc.c
index a1dafc9..87bd346 100644
--- a/usr/mgmt_ipc.c
+++ b/usr/mgmt_ipc.c
@@ -39,6 +39,7 @@
 
 #define PEERUSER_MAX	64
 #define EXTMSG_MAX	(64 * 1024)
+#define SD_SOCKET_FDS_START 3
 
 int
 mgmt_ipc_listen(void)
@@ -46,6 +47,12 @@ mgmt_ipc_listen(void)
 	int fd, err, addr_len;
 	struct sockaddr_un addr;
 
+	/* first check if we have fd handled by systemd */
+	fd = mgmt_ipc_systemd();
+	if (fd >= 0)
+		return fd;
+
+	/* manually establish a socket */
 	fd = socket(AF_LOCAL, SOCK_STREAM, 0);
 	if (fd < 0) {
 		log_error("Can not create IPC socket");
@@ -73,6 +80,28 @@ mgmt_ipc_listen(void)
 	return fd;
 }
 
+int mgmt_ipc_systemd(void)
+{
+	const char *env;
+
+	env = getenv("LISTEN_PID");
+
+	if (!env || (strtoul(env, NULL, 10) != getpid()))
+		return -EINVAL;
+
+	env = getenv("LISTEN_FDS");
+
+	if (!env)
+		return -EINVAL;
+
+	if (strtoul(env, NULL, 10) != 1) {
+		log_error("Did not receive exactly one IPC socket from systemd");
+		return -EINVAL;
+	}
+
+	return SD_SOCKET_FDS_START;
+}
+
 void
 mgmt_ipc_close(int fd)
 {
diff --git a/usr/mgmt_ipc.h b/usr/mgmt_ipc.h
index 7d8ce72..55972ed 100644
--- a/usr/mgmt_ipc.h
+++ b/usr/mgmt_ipc.h
@@ -112,6 +112,7 @@ typedef int mgmt_ipc_fn_t(struct queue_task *);
 struct queue_task;
 void mgmt_ipc_write_rsp(struct queue_task *qtask, int err);
 int mgmt_ipc_listen(void);
+int mgmt_ipc_systemd(void);
 void mgmt_ipc_close(int fd);
 void mgmt_ipc_handle(int accept_fd);
 
-- 
1.7.2.3


From c34e0bdcbafdb6f9304e1474d51fe1c789c5dea2 Mon Sep 17 00:00:00 2001
From: Tomasz Torcz <tomek@pipebreaker.pl>
Date: Wed, 28 Nov 2012 13:37:08 +0100
Subject: [PATCH] iscsid: add example unit files for systemd
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Those two units, based on the work by Jóhann B. Guðmundsson, exploit
on-demand socket activation in iscsid.
---
 etc/systemd/iscsid.service |   13 +++++++++++++
 etc/systemd/iscsid.socket  |    9 +++++++++
 2 files changed, 22 insertions(+), 0 deletions(-)
 create mode 100644 etc/systemd/iscsid.service
 create mode 100644 etc/systemd/iscsid.socket

diff --git a/etc/systemd/iscsid.service b/etc/systemd/iscsid.service
new file mode 100644
index 0000000..028e0b3
--- /dev/null
+++ b/etc/systemd/iscsid.service
@@ -0,0 +1,13 @@
+[Unit]
+Description=Open-iSCSI
+Documentation=man:iscsid(8) man:iscsiuio(8) man:iscsiadm(8)
+After=network.target NetworkManager-wait-online.service iscsiuio.service tgtd.service targetcli.service
+
+[Service]
+Type=forking
+PIDFile=/var/run/iscsid.pid
+ExecStart=/usr/sbin/iscsid
+ExecStop=/sbin/iscsiadm -k 0 2
+
+[Install]
+WantedBy=multi-user.target
diff --git a/etc/systemd/iscsid.socket b/etc/systemd/iscsid.socket
new file mode 100644
index 0000000..832451d
--- /dev/null
+++ b/etc/systemd/iscsid.socket
@@ -0,0 +1,9 @@
+[Unit]
+Description=Open-iSCSI iscsid Socket
+Documentation=man:iscsid(8) man:iscsiuio(8) man:iscsiadm(8)
+
+[Socket]
+ListenStream=@ISCSIADM_ABSTRACT_NAMESPACE
+
+[Install]
+WantedBy=sockets.target
-- 
1.7.2.3


From a7afdf46c3193eb102cc6ec2a3b61e8d36794437 Mon Sep 17 00:00:00 2001
From: Mike Christie <michaelc@cs.wisc.edu>
Date: Fri, 14 Dec 2012 12:40:27 -0600
Subject: [PATCH] iscsi tools: fix get_random_bytes error handling

Bug report from Rahul:

There seems to be a bug in function get_random_bytes(). I reported
this earlier as well but somehow it didn't appear here.

get_random_bytes(unsigned char *data, unsigned int length)
{
	long r;
        unsigned n;
	int fd;

	fd = open("/dev/urandom", O_RDONLY);
        	while (length > 0) {

	if (!fd || read(fd, &r, sizeof(long)) != -1)      <<<< the condition is
incorrect
---
 usr/auth.c |    8 ++++----
 1 files changed, 4 insertions(+), 4 deletions(-)

diff --git a/usr/auth.c b/usr/auth.c
index c924545..4ff0425 100644
--- a/usr/auth.c
+++ b/usr/auth.c
@@ -189,24 +189,24 @@ get_random_bytes(unsigned char *data, unsigned int length)
 
 	long r;
         unsigned n;
-	int fd;
+	int fd, r_size = sizeof(r);
 
 	fd = open("/dev/urandom", O_RDONLY);
         while (length > 0) {
 
-		if (!fd || read(fd, &r, sizeof(long)) != -1)
+		if (fd == -1 || read(fd, &r, r_size) != r_size)
 			r = rand();
                 r = r ^ (r >> 8);
                 r = r ^ (r >> 4);
                 n = r & 0x7;
 
-		if (!fd || read(fd, &r, sizeof(long)) != -1)
+		if (fd == -1 || read(fd, &r, r_size) != r_size)
 			r = rand();
                 r = r ^ (r >> 8);
                 r = r ^ (r >> 5);
                 n = (n << 3) | (r & 0x7);
 
-		if (!fd || read(fd, &r, sizeof(long)) != -1)
+		if (fd == -1 || read(fd, &r, r_size) != r_size)
 			r = rand();
                 r = r ^ (r >> 8);
                 r = r ^ (r >> 5);
-- 
1.7.2.3

