# --- SDE-COPYRIGHT-NOTE-BEGIN ---
# This copyright note is auto-generated by ./scripts/Create-CopyPatch.
#
# Filename: package/.../musl/pkg/lvm2/lvm2-musl-0001-read-only-assignment.patch
# Copyright (C) 2012 - 2014 The OpenSDE Project
#
# More information can be found in the files COPYING and README.
#
# This patch file is dual-licensed. It is available under the license the
# patched project is licensed under, as long as it is an OpenSource license
# as defined at http://www.opensource.org/ (e.g. BSD, X11) or under the terms
# of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
# --- SDE-COPYRIGHT-NOTE-END ---

lib/commands/toolcontext.c
-------------------------------------------------------------------------------
commands/toolcontext.c: In function 'create_toolcontext':
commands/toolcontext.c:1427:4: error: assignment of read-only variable 'stdin'
commands/toolcontext.c:1439:4: error: assignment of read-only variable 'stdout'
commands/toolcontext.c: In function 'destroy_toolcontext':
commands/toolcontext.c:1757:5: error: assignment of read-only variable 'stdin'
commands/toolcontext.c:1767:5: error: assignment of read-only variable 'stdout'
-------------------------------------------------------------------------------

tools/lvmcmdline.c
-------------------------------------------------------------------------------
lvmcmdline.c: In function '_check_standard_fds':
lvmcmdline.c:1255:6: error: assignment of read-only variable 'stdin'
lvmcmdline.c:1265:6: error: assignment of read-only variable 'stdout'
lvmcmdline.c:1273:6: error: assignment of read-only variable 'stderr'
-------------------------------------------------------------------------------

--- a/tools/lvmcmdline.c	2013-11-13 15:12:23.000000000 +0100
+++ b/tools/lvmcmdline.c	2014-01-11 13:08:11.746838326 +0100
@@ -1250,9 +1250,12 @@
 static int _check_standard_fds(void)
 {
 	int err = is_valid_fd(STDERR_FILENO);
+	FILE *stdin_stream = stdin;
+	FILE *stdout_stream = stdout;
+	FILE *stderr_stream = stderr;
 
 	if (!is_valid_fd(STDIN_FILENO) &&
-	    !(stdin = fopen(_PATH_DEVNULL, "r"))) {
+	    !(stdin_stream = fopen(_PATH_DEVNULL, "r"))) {
 		if (err)
 			perror("stdin stream open");
 		else
@@ -1262,7 +1265,7 @@
 	}
 
 	if (!is_valid_fd(STDOUT_FILENO) &&
-	    !(stdout = fopen(_PATH_DEVNULL, "w"))) {
+	    !(stdout_stream = fopen(_PATH_DEVNULL, "w"))) {
 		if (err)
 			perror("stdout stream open");
 		/* else no stdout */
@@ -1270,7 +1273,7 @@
 	}
 
 	if (!is_valid_fd(STDERR_FILENO) &&
-	    !(stderr = fopen(_PATH_DEVNULL, "w"))) {
+	    !(stderr_stream = fopen(_PATH_DEVNULL, "w"))) {
 		printf("stderr stream open: %s\n",
 		       strerror(errno));
 		return 0;
--- a/lib/commands/toolcontext.c	2014-01-11 13:08:11.746838326 +0100
+++ b/lib/commands/toolcontext.c	2014-01-11 18:43:42.136857198 +0100
@@ -1373,6 +1373,8 @@
 {
 	struct cmd_context *cmd;
 	FILE *new_stream;
+	FILE *stdin_stream = stdin;
+	FILE *stdout_stream = stdout;
 	int flags;
 
 #ifdef M_MMAP_MAX
@@ -1422,10 +1424,10 @@
 		if (is_valid_fd(STDIN_FILENO) &&
 		    ((flags = fcntl(STDIN_FILENO, F_GETFL)) > 0) &&
 		    (flags & O_ACCMODE) != O_WRONLY) {
-			if (!_reopen_stream(stdin, STDIN_FILENO, "r", "stdin", &new_stream))
+			if (!_reopen_stream(stdin_stream, STDIN_FILENO, "r", "stdin", &new_stream))
 				goto_out;
-			stdin = new_stream;
-			if (setvbuf(stdin, cmd->linebuffer, _IOLBF, linebuffer_size)) {
+			stdin_stream = new_stream;
+			if (setvbuf(stdin_stream, cmd->linebuffer, _IOLBF, linebuffer_size)) {
 				log_sys_error("setvbuf", "");
 				goto out;
 			}
@@ -1434,10 +1436,10 @@
 		if (is_valid_fd(STDOUT_FILENO) &&
 		    ((flags = fcntl(STDOUT_FILENO, F_GETFL)) > 0) &&
 		    (flags & O_ACCMODE) != O_RDONLY) {
-			if (!_reopen_stream(stdout, STDOUT_FILENO, "w", "stdout", &new_stream))
+			if (!_reopen_stream(stdout_stream, STDOUT_FILENO, "w", "stdout", &new_stream))
 				goto_out;
-			stdout = new_stream;
-			if (setvbuf(stdout, cmd->linebuffer + linebuffer_size,
+			stdout_stream = new_stream;
+			if (setvbuf(stdout_stream, cmd->linebuffer + linebuffer_size,
 				     _IOLBF, linebuffer_size)) {
 				log_sys_error("setvbuf", "");
 				goto out;
@@ -1717,6 +1719,8 @@
 {
 	struct dm_config_tree *cft_cmdline;
 	FILE *new_stream;
+	FILE *stdin_stream = stdin;
+	FILE *stdout_stream = stdout;
 	int flags;
 
 	if (cmd->dump_filter && cmd->filter && cmd->filter->dump &&
@@ -1753,9 +1757,9 @@
 		if (is_valid_fd(STDIN_FILENO) &&
 		    ((flags = fcntl(STDIN_FILENO, F_GETFL)) > 0) &&
 		    (flags & O_ACCMODE) != O_WRONLY) {
-			if (_reopen_stream(stdin, STDIN_FILENO, "r", "stdin", &new_stream)) {
-				stdin = new_stream;
-				setlinebuf(stdin);
+			if (_reopen_stream(stdin_stream, STDIN_FILENO, "r", "stdin", &new_stream)) {
+				stdin_stream = new_stream;
+				setlinebuf(stdin_stream);
 			} else
 				cmd->linebuffer = NULL;	/* Leave buffer in place (deliberate leak) */
 		}
@@ -1763,9 +1767,9 @@
 		if (is_valid_fd(STDOUT_FILENO) &&
 		    ((flags = fcntl(STDOUT_FILENO, F_GETFL)) > 0) &&
 		    (flags & O_ACCMODE) != O_RDONLY) {
-			if (_reopen_stream(stdout, STDOUT_FILENO, "w", "stdout", &new_stream)) {
-				stdout = new_stream;
-				setlinebuf(stdout);
+			if (_reopen_stream(stdout_stream, STDOUT_FILENO, "w", "stdout", &new_stream)) {
+				stdout_stream = new_stream;
+				setlinebuf(stdout_stream);
 			} else
 				cmd->linebuffer = NULL;	/* Leave buffer in place (deliberate leak) */
 		}
